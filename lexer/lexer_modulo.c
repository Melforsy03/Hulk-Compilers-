#include <string.h>
#include "lexer_modulo.h"
extern AnalizadorLexico lexer;
Token analizar(const char* lexema) {
    if (strcmp(lexema, "let") == 0) return (Token){TOKEN_LET, lexema, lexer.linea};
    if (strcmp(lexema, "in") == 0) return (Token){TOKEN_IN, lexema, lexer.linea};
    if (strcmp(lexema, "function") == 0) return (Token){TOKEN_FUNCTION, lexema, lexer.linea};
    if (strcmp(lexema, "type") == 0) return (Token){TOKEN_TYPE, lexema, lexer.linea};
    if (strcmp(lexema, "if") == 0) return (Token){TOKEN_IF, lexema, lexer.linea};
    if (strcmp(lexema, "then") == 0) return (Token){TOKEN_THEN, lexema, lexer.linea};
    if (strcmp(lexema, "elif") == 0) return (Token){TOKEN_ELIF, lexema, lexer.linea};
    if (strcmp(lexema, "else") == 0) return (Token){TOKEN_ELSE, lexema, lexer.linea};
    if (strcmp(lexema, "while") == 0) return (Token){TOKEN_WHILE, lexema, lexer.linea};
    if (strcmp(lexema, "for") == 0) return (Token){TOKEN_FOR, lexema, lexer.linea};
    if (strcmp(lexema, "true") == 0) return (Token){TOKEN_TRUE, lexema, lexer.linea};
    if (strcmp(lexema, "false") == 0) return (Token){TOKEN_FALSE, lexema, lexer.linea};
    if (strcmp(lexema, "new") == 0) return (Token){TOKEN_NEW, lexema, lexer.linea};
    if (strcmp(lexema, "inherits") == 0) return (Token){TOKEN_INHERITS, lexema, lexer.linea};
    if (strcmp(lexema, "self") == 0) return (Token){TOKEN_SELF, lexema, lexer.linea};
    if (strcmp(lexema, "base") == 0) return (Token){TOKEN_BASE, lexema, lexer.linea};
    if (strcmp(lexema, "return") == 0) return (Token){TOKEN_RETURN, lexema, lexer.linea};
    if (strcmp(lexema, "Print") == 0) return (Token){TOKEN_PRINT, lexema, lexer.linea};
    if (strcmp(lexema, "range") == 0) return (Token){TOKEN_RANGE, lexema, lexer.linea};
    if (strcmp(lexema, "+") == 0) return (Token){TOKEN_PLUS, lexema, lexer.linea};
    if (strcmp(lexema, "-") == 0) return (Token){TOKEN_MINUS, lexema, lexer.linea};
    if (strcmp(lexema, "*") == 0) return (Token){TOKEN_STAR, lexema, lexer.linea};
    if (strcmp(lexema, "/") == 0) return (Token){TOKEN_SLASH, lexema, lexer.linea};
    if (strcmp(lexema, "^") == 0) return (Token){TOKEN_POWER, lexema, lexer.linea};
    if (strcmp(lexema, "@") == 0) return (Token){TOKEN_AT, lexema, lexer.linea};
    if (strcmp(lexema, "=") == 0) return (Token){TOKEN_ASSIGN, lexema, lexer.linea};
    if (strcmp(lexema, ":=") == 0) return (Token){TOKEN_COLON_EQUAL, lexema, lexer.linea};
    if (strcmp(lexema, "==") == 0) return (Token){TOKEN_EQUAL_EQUAL, lexema, lexer.linea};
    if (strcmp(lexema, "!=") == 0) return (Token){TOKEN_NOT_EQUAL, lexema, lexer.linea};
    if (strcmp(lexema, "<") == 0) return (Token){TOKEN_LESS, lexema, lexer.linea};
    if (strcmp(lexema, "<=") == 0) return (Token){TOKEN_LESS_EQUAL, lexema, lexer.linea};
    if (strcmp(lexema, ">") == 0) return (Token){TOKEN_GREATER, lexema, lexer.linea};
    if (strcmp(lexema, ">=") == 0) return (Token){TOKEN_GREATER_EQUAL, lexema, lexer.linea};
    if (strcmp(lexema, "&&") == 0) return (Token){TOKEN_AND, lexema, lexer.linea};
    if (strcmp(lexema, "||") == 0) return (Token){TOKEN_OR, lexema, lexer.linea};
    if (strcmp(lexema, "!") == 0) return (Token){TOKEN_NOT, lexema, lexer.linea};
    if (strcmp(lexema, "=>") == 0) return (Token){TOKEN_ARROW, lexema, lexer.linea};
    if (strcmp(lexema, ".") == 0) return (Token){TOKEN_DOT, lexema, lexer.linea};
    if (strcmp(lexema, "(") == 0) return (Token){TOKEN_LPAREN, lexema, lexer.linea};
    if (strcmp(lexema, ")") == 0) return (Token){TOKEN_RPAREN, lexema, lexer.linea};
    if (strcmp(lexema, "{") == 0) return (Token){TOKEN_LBRACE, lexema, lexer.linea};
    if (strcmp(lexema, "}") == 0) return (Token){TOKEN_RBRACE, lexema, lexer.linea};
    if (strcmp(lexema, ",") == 0) return (Token){TOKEN_COMMA, lexema, lexer.linea};
    if (strcmp(lexema, ";") == 0) return (Token){TOKEN_SEMICOLON, lexema, lexer.linea};
    return (Token){TOKEN_ERROR, lexema, lexer.linea};
}
